这个玩意是stack，遵循后进先出的规则。
在设计的时候，有两种方法 
1：用数组实现（同样也是最容易的实现方法）
2：用链表实现（这个链表的对stack的实现有点东西）

我们来看第一种：
为了不那么松散，我们引入了一个结构体，然后用一个结构体指针来操作这个结构体。那么这个结构体会有什么东西呢
那么就是：1数组的最大容量2操作数组（栈）的指针（实际是个值，当做数组的index）3数组（作为栈的主体）
然后就是实现的细节：
step1：创建，那么需要什么内容呢？无非就是数组的大小，结构体（这里也要创造一个，不然连最基本的结构体都没有，怎么可能有里边的数组）的大小，然后书上还提供了一个最小的容量。malloc之后返回指向这个结构体的指针。之后就可以通过这个指针来操作结构体。
step2：用结构体里的那个index来操作数组，初始化为-1，也就是当前stack为空，之后通过自增，自减来实现push，pop，由于是指针操作值，所以可以直接改变值的内容。核心就是这么个玩意，之后遍历可以直接遍历到这个index的值，当做当前的stack。
step3：然后就是细节的实现了，比如判断是否为full，是否为empty，然后取top的值，取top的值后将这个值pop掉，这些一看就知道怎么实现了，对于这种边界的判断，我们应该注意一手。


然后是第二种：
第二种的核心是一样的，但是链表的特点，取最后的值是不好弄的，所以我们反过来思考，就是把最前面的值当做为top，之后对它进行操作，这就好操作多了，然后因为Push就将head指向push的内容，然后pop就是删除第一个节点， 最难想的是将这个链表头当做为栈顶，因为数组是把尾当做栈顶，这样就很容易会顺着想，但这是错的哟。

栈也是非常有用的：比如 1：进行配对判断，平衡符号，如果是单，则push，有配对后进行pop 由于是成双，那么一定会有两个配对是挨着的，然后一对一对弹出就可以了。你比如()() 或者 ([])  更复杂的也就是这两种的套了，实际都一样，没区别

2：波兰表达式和逆波兰 这就是前缀转中缀，中缀转后缀，这个前缀后缀中缀在树那块也有，好像还差不多 用树，用栈都能写，这里主要是代码，就不写这些了
3：函数调用：经典中的经典，不必多说。